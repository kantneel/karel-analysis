
# {"code": 
# 		{"info": {"candidates": [["DEF", "run", "m(", "move", "pickMarker", "m)"]], "trees_checked": 1},
# 		 "code_sequence": [],
# 		 "code_tree": []
# 		},
#  "stats": {"result-none": 0, "runtime-exception": 0, "syntax-error": 0, "exceptions": 0, "total": 6, "correct": 0}, 
#  "example": 
# 	    {"code": ["DEF", "run", "m(", "move", "putMarker", "m)"],
# 	     "guid": "b9637eed2a253a87", 
# 	     "examples": [{"out": [542, 1620, 1621, 1622, 1623, 1624, 1638, 1642, 1656, 1660, 1674, 1678, 1692, 1696, 1710, 1714, 1728, 1732, 1746, 1750, 1764, 1768, 1782, 1786, 1800, 1804, 1818, 1822, 1836, 1840, 1854, 1858, 1872, 1876, 1890, 1891, 1892, 1893, 1894, 1999, 2162, 4232], "in": [541, 1620, 1621, 1622, 1623, 1624, 1638, 1642, 1656, 1660, 1674, 1678, 1692, 1696, 1710, 1714, 1728, 1732, 1746, 1750, 1764, 1768, 1782, 1786, 1800, 1804, 1818, 1822, 1836, 1840, 1854, 1858, 1872, 1876, 1890, 1891, 1892, 1893, 1894, 1999, 4232]}, {"out": [370, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1655, 1656, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1968, 1972, 1983, 1984, 1990, 3598], "in": [369, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1655, 1656, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1968, 1972, 1983, 1984, 3598]}, {"out": [704, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1638, 1650, 1656, 1668, 1674, 1686, 1692, 1704, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1969, 2324, 2653, 3284, 3933, 3935], "in": [722, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1638, 1650, 1656, 1668, 1674, 1686, 1692, 1704, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1969, 2000, 2653, 3284, 3933, 3935]}, {"out": [344, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1638, 1648, 1656, 1666, 1674, 1684, 1692, 1702, 1710, 1720, 1728, 1738, 1746, 1756, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1964, 1987, 2017, 2036, 2058], "in": [343, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1638, 1648, 1656, 1666, 1674, 1684, 1692, 1702, 1710, 1720, 1728, 1738, 1746, 1756, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1987, 2017, 2036, 2058]}, {"out": [44, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1638, 1649, 1656, 1667, 1674, 1685, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1988, 1989, 2002, 2324, 2612], "in": [26, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1638, 1649, 1656, 1667, 1674, 1685, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1989, 2002, 2324, 2612]}, {"out": [63, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1638, 1650, 1656, 1668, 1674, 1686, 1692, 1704, 1710, 1722, 1728, 1740, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 2007, 2054, 2061, 3314, 3606, 3949, 4293, 4309], "in": [45, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1638, 1650, 1656, 1668, 1674, 1686, 1692, 1704, 1710, 1722, 1728, 1740, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 2054, 2061, 3314, 3606, 3949, 4293, 4309]}]
# 		}
# }

import json
import numpy as np
import itertools

def featurize(episode):
	"""
	Input: a dictionary which represents an evaluated point in the validation set. 
	Output: a list of features about the evaluated point.
 
	Currently assumes a single candidate code sequence per trial.
	"""

	correct = int(episode['stats']['correct'] == 6) # whether the model got it right

	# model_out = featurize_code(episode['code']['info']['candidates'][0])
	featurized_code = featurize_code(episode['example']['code']) # 18 features

	maps = episode['example']['examples'] # list of all of the i/o pairs

	in_featurized = [featurize_io(m['in']) for m in maps] # 6 x 7 = 42 features
	delta_featurized = [featurize_delta(m['in'], m['out']) for m in maps] # 6 x 6 = 36 features

	featurized_io = [t[0] + t[1] for t in zip(in_featurized, delta_featurized)]
	flat_featurized_io = list(itertools.chain.from_iterable(featurized_io))

	return featurized_code + flat_featurized_io, correct

def get_one_hot(indices):
	"""
	Input: a list of indices which refer to positions marked "True" in a Karel grid.
	Output: a one-hot numpy array for the grid.
	"""
	grid = np.zeros((15, 18, 18))
	grid.ravel()[indices] = 1

	return grid

def featurize_io(map_indices):
	"""
	Input: a list of indices which refer to positions marked "True" in a Karel grid.
	Output: a list of features about the input grid.

	Current features: perimeter, area, number of interior walls,
	max number of markers in a spot, number of spots with markers, total number of markers
	6 total.
	"""
	one_hot = get_one_hot(map_indices)

	height = int(np.sum(one_hot[5], axis=0)[0] - 2)
	width = int(np.sum(one_hot[5], axis=1)[0] - 2)

	perimiter = height + width
	area = height * width

	num_int_walls = np.sum(one_hot[4])

	shared_edges = 0
	for i in range(1, height + 1):
		for j in range(1, width + 1):
			if one_hot[4, i, j] == 1:

				# sum up the number of edges that are against another wall  
				up_down = one_hot[4, i + 1, j] + one_hot[4, i - 1, j]
				up_down += int(i == 1 or i == height)
				left_right = one_hot[4, i, j + 1] + one_hot[4, i, j - 1]
				left_right += int(i == 1 or i == width)

				shared_edges += up_down + left_right

	exposed_edges = 4 * num_int_walls - shared_edges # tells you something about interior walls...

	total_markers = 0 
	max_markers = 0
	spots_markers = 0
	for i in range(1, 10):
		i_markers = np.sum(one_hot[i + 5])
		if i_markers > 0:
			max_markers = i
			spots_markers += i_markers
			total_markers += i * i_markers

	return [perimiter, area, num_int_walls, exposed_edges, total_markers, max_markers, spots_markers]

def featurize_delta(map_in, map_out):
	"""
	Input: two lists of indices (as per featurize_io), for in and out Karel maps. 
	Output: a list of features about the difference between the two maps.

	Current features: changes in marker stats (as per featurize_io), 
	whether Karel is facing in the same direction, the change in Karel's position (x, y)
	6 total.
	"""
	in_rep = get_one_hot(map_in)
	out_rep = get_one_hot(map_out)

	in_features = featurize_io(map_in)
	out_features = featurize_io(map_out)

	marker_diffs = [in_features[i] - out_features[i] for i in range(3, 6)]

	# find direction hero is facing (in, out)
	in_facing = np.argmax([np.max(in_rep[i]) for i in range(3)])
	out_facing = np.argmax([np.max(out_rep[i]) for i in range(3)])

	# find coordinates of hero (in, out)
	in_coords = np.unravel_index(np.argmax(in_rep[in_facing]), (18, 18))
	out_coords = np.unravel_index(np.argmax(out_rep[out_facing]), (18, 18))


	face_change = int(in_facing == out_facing)
	movedx = np.abs(in_coords[0] - out_coords[0]) 
	movedy = np.abs(in_coords[1] - out_coords[1])

	return [face_change, movedx, movedy] + marker_diffs


def featurize_code(code_string):
	"""
	Input: a list of tokens corresponding to the target code sequence
	Output: a list of features about the code.

	Current features: program length, a measure of program depth, 
	and a bag of words representation. 
	18 total.
	"""

	length = len(code_string)

	# no case-switch lol
	# bag of words 
	token_dict = {
		'move'				: 0,
		'putMarker' 		: 1, 
		'pickMarker' 		: 2, 
		'i('				: 3, 
		'e('				: 4, 
		'w('				: 5, 
		'r('				: 6,  
		'frontIsClear'		: 7,
		'leftIsClear'		: 8, 
		'rightIsClear'  	: 9, 
		'not'				: 10, 
		'turnLeft'			: 11, 
		'turnRight'			: 12, 
		'markersPresent'	: 13, 
		'noMarkersPresent'	: 14
		# Repeats (R=*)		: 15	
	}
	
	bag_of_words = [0 for i in range(16)]
	depth_counter = [0 for i in range(length)] 

	for i, token in enumerate(code_string):
		if token in token_dict:
			bag_of_words[token_dict[token]] += 1
		elif 'R=' in token:
			bag_of_words[15] += 1
		
		if '(' in token and 'm' not in token:
			depth_counter[i] = depth_counter[i - 1] + 1
		elif ')' in token and 'm' not in token:
			depth_counter[i] = depth_counter[i - 1] - 1
		else:
			depth_counter[i] = depth_counter[max(i - 1, 0)]

	program_depth = sum(depth_counter)

	return [length, program_depth] + bag_of_words

if __name__ == '__main__':

	# Main function: 
	# 1. read data from json.
	# 2. featurize it. 
	# 3. save it into numpy arrays. 

	FILENAME = "report-train.json"
	NUM_FEATURES = 96 # 42 + 36 + 18 = 96 features (check out featurize for details).

	f = open(FILENAME)
	overall_stats = json.loads(f.readline()) # ex {"syntax-error": 0, "total": 192, "correct": 3, "runtime-exception": 0}
	num_records = overall_stats['total']

	data_array = np.zeros((num_records, NUM_FEATURES))
	label_array = np.zeros(num_records)

	for i in range(num_records):
		episode_dict = json.loads(f.readline())
		featurized, label = featurize(episode_dict)

		data_array[i] = featurized
		label_array[i] = label

	np.savetxt('data.csv', data_array.astype(int), delimiter=',')
	np.savetxt('labels.csv', label_array.astype(int), delimiter=',')

